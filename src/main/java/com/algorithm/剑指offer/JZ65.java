package com.algorithm.剑指offer;

/**
 * @ClassName JZ65
 * @Description TODO
 * @Author bill
 * @Date 2021/9/18 16:26
 * @Version 1.0
 **/
/*
不用加减乘除做加法

写一个函数，求两个整数之和，要求在函数体内不得使用 “+”、“-”、“*”、“/” 四则运算符号。

加法结果 = 不带进位的 + 只考虑进位结果的
异或也叫半加运算，其运算法则相当于不带进位的二进制加法:不同为1 相同为0  ：1^1=0  1^0=1
 */

// 设两数字的二进制形式a、b, 其求和s = a + b, a(i)代表a的二进制第i位, 则分为以下四种情况:
//   a(i)  b(i)  无进位和n(i) 进位c(i+1)
//    0     0         0           0
//    0     1         1           0
//    1     0         1           0
//    1     1         0           1
//
// 观察发现，无进位和与"异或运算"规律相同，进位和"与运算"规律相同(并需左移一位)
// 因此,无进位和n与进位c的计算公式如下:
//                                     n =  a ^ b         非进位和: 异或运算
//                                     c = (a & b) << 1    进位: 与运算+左移一位
// 因为 (和s) = (非进位和n) + (进位c) ，所以即可将 s = a + b 转化为 s = n + c ，即 s = a ^ b + (a & b) << 1
//
// 采用递归思想: 虽然s = a + b = n + c，但是n + c还是用了'+'，因此我们对n + c再次采用这种运算 (也就是把n当成a，c当成b，继续做a+b运算。看似无限循环，但是进位c总会有等于0的时候，此时结果就等于n)
// 非递归同理，循环求n和c，直至进位c = 0; 此时s = n, 返回n即可。
public class JZ65 {
    //1、递归
    public int add(int a, int b) {
        if (b == 0) {
            return a;
        }
        return add(a ^ b, (a & b) << 1);
    }

    //2、非递归
    public int add1(int a, int b) {
        while (b != 0) {
            int c = (a & b) << 1;
            a ^= b;
            b = c;
        }
        return a;
    }
}
